use std::{
    sync::{Mutex},
};

use once_cell::sync::Lazy;

use crate::autocxxsubclass::{
    AutocxxSubclass, AutocxxSubclassHolder, AutocxxSubclassPeer, AutocxxSubclassSelfOwned,
    CppPeerHolder,
};
#[cxx::bridge]
mod test_utils {
    extern "Rust" {
        fn mark_allocated();
        fn mark_freed();
    }
}

#[cxx::bridge]
mod ffi {
    unsafe extern "C++" {
        include!("autocxx-subclass-demo/include/test.h");
        type MyTestObserverCpp;
        fn MyTestObserverCpp_make_unique(
            rs_peer: Box<MyTestObserverHolder>,
        ) -> UniquePtr<MyTestObserverCpp>;
        fn MyTestObserverCpp_remove_ownership(self: Pin<&mut MyTestObserverCpp>);
        fn TriggerTestObserverA(obs: Pin<&mut MyTestObserverCpp>);
    }

    extern "Rust" {
        type MyTestObserverHolder;

        pub(crate) fn MyTestObserver_a(me: &MyTestObserverHolder);
        pub(crate) fn MyTestObserver_RelinquishOwnership(me: &mut MyTestObserverHolder);
    }
    impl UniquePtr<MyTestObserverCpp> {}
}

impl ffi::MyTestObserverCpp {
    fn make_unique(peer: AutocxxSubclassHolder<MyTestObserver>) -> cxx::UniquePtr<ffi::MyTestObserverCpp> {
        ffi::MyTestObserverCpp_make_unique(Box::new(MyTestObserverHolder(peer)))
    }
}

// Autogenerated
pub struct MyTestObserverHolder(pub AutocxxSubclassHolder<MyTestObserver>);

impl AutocxxSubclassPeer for ffi::MyTestObserverCpp {
    fn relinquish_ownership(self: std::pin::Pin<&mut Self>) {
        self.MyTestObserverCpp_remove_ownership();
    }
}

#[allow(non_snake_case)]
pub fn MyTestObserver_a(me: &MyTestObserverHolder) {
    if let Some(r) = me.0.get() {
        r.as_ref().borrow_mut().a();
    }
}

#[allow(non_snake_case)]
pub fn MyTestObserver_RelinquishOwnership(me: &mut MyTestObserverHolder) {
    me.0.relinquish_ownership();
}

// End autogenerated

fn mark_allocated() {
    Lazy::force(&STATUS).lock().unwrap().cpp_allocated = true;
}

fn mark_freed() {
    Lazy::force(&STATUS).lock().unwrap().cpp_allocated = false;
}

#[derive(Default)]
struct Status {
    cpp_allocated: bool,
    rust_allocated: bool,
    a_called: bool,
}

static STATUS: Lazy<Mutex<Status>> = Lazy::new(|| Mutex::new(Status::default()));

pub struct ExternalEngine;

impl ExternalEngine {
    fn do_something(&self) {
        Lazy::force(&STATUS).lock().unwrap().a_called = true;
    }
}

impl Default for ExternalEngine {
    fn default() -> Self {
        Lazy::force(&STATUS).lock().unwrap().rust_allocated = true;
        ExternalEngine
    }
}

impl Drop for ExternalEngine {
    fn drop(&mut self) {
        Lazy::force(&STATUS).lock().unwrap().rust_allocated = false;
    }
}

#[derive(Default)]
pub struct MyTestObserver {
    cpp_peer: CppPeerHolder<ffi::MyTestObserverCpp>,
    data: ExternalEngine,
}

impl MyTestObserver {
    fn new() -> Self {
        Self {
            cpp_peer: Default::default(),
            data: ExternalEngine::default(),
        }
    }
}

impl AutocxxSubclass<ffi::MyTestObserverCpp> for MyTestObserver {
    fn get_peer(&mut self) -> &mut CppPeerHolder<ffi::MyTestObserverCpp> {
        &mut self.cpp_peer
    }
}

impl AutocxxSubclassSelfOwned<ffi::MyTestObserverCpp> for MyTestObserver {}

#[allow(non_snake_case)]
impl MyTestObserver {
    pub(crate) fn a(&mut self) {
        self.data.do_something();
    }
}

// pub fn make_cpp_observer() -> cxx::UniquePtr<ffi::MyWebContentsObserverCpp> {
//     MyWebContentsObserver::make_cpp_owned(
//         MyWebContentsObserver {
//             cpp_peer: Default::default(),
//             data: ExternalEngine,
//         },
//         ffi::MyWebContentsObserverCpp::make_unique,
//     )
// }

#[test]
fn tests() { // must be single threaded due to global Status
    assert!(!Lazy::force(&STATUS).lock().unwrap().cpp_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().rust_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().a_called);
    let mut obs = MyTestObserver::make_cpp_owned(
        MyTestObserver::new(),
        ffi::MyTestObserverCpp::make_unique,
    );
    assert!(Lazy::force(&STATUS).lock().unwrap().cpp_allocated);
    assert!(Lazy::force(&STATUS).lock().unwrap().rust_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().a_called);
    ffi::TriggerTestObserverA(obs.pin_mut());
    assert!(Lazy::force(&STATUS).lock().unwrap().a_called);
    std::mem::drop(obs);
    Lazy::force(&STATUS).lock().unwrap().a_called = false;
    assert!(!Lazy::force(&STATUS).lock().unwrap().rust_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().cpp_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().a_called);
    let obs = MyTestObserver::make_rust_owned(
        MyTestObserver::new(),
        ffi::MyTestObserverCpp::make_unique,
    );
    let cpp_peer_ptr = unsafe { obs.borrow_mut().pin_peer().get_unchecked_mut() as *mut ffi::MyTestObserverCpp };
    assert!(Lazy::force(&STATUS).lock().unwrap().cpp_allocated);
    assert!(Lazy::force(&STATUS).lock().unwrap().rust_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().a_called);
    ffi::TriggerTestObserverA(unsafe{std::pin::Pin::new_unchecked(&mut *cpp_peer_ptr)});
    assert!(Lazy::force(&STATUS).lock().unwrap().a_called);
    Lazy::force(&STATUS).lock().unwrap().a_called = false;
    std::mem::drop(obs);
    assert!(!Lazy::force(&STATUS).lock().unwrap().rust_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().cpp_allocated);
    assert!(!Lazy::force(&STATUS).lock().unwrap().a_called);
}
